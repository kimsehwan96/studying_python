# 내장 시퀀스 타입

## 파이썬 내장 시퀀스 데이터 타입
* 멤버십 연산 : in 키워드 사용
* 크기 함수 : len(seq)
* 슬라이싱 속성 : seq[:-1]
* 반복성 : 반복문에 있는 데이터를 순회 할 수 있음

파이썬에는 `문자열, 튜플, 리스트, 바이트 배열, 바이트 ` 등 5개의 내장 시퀀스 타입이 있다.

## immutable 과 mutable

` 튜플, 문자열, 바이트 배열 `은 immutable 
` 리스트, 바이트 ` 는 mutable

# 얕은 복사와 깊은 복사

    얕은 복사와 깊은 복사의 차이점은 바로 mutable과 immutable의 차이에서 발생하는데..
    파이썬은 기본적으로 '객체 참조' 를 한다.
    예를들어 리스트 li = ['kim', 'se', 'hwan'] 을 생성했다면 리스트 안에 값이 쏙 들어 간 것이 아닌
    'kim', 'se', 'hwan' 이라는 각각의 객체를 리스트가 참조 중인 셈이다.

    이 때 li_2 = list(li) 를 하먄 전달된 내용이 담긴 새로운 리스트 li_2가 만들어지는데 
    li와 그 내용은 동일하다. 이 때 li와 li_2는 모두 동일한 객체를 '참조' 중인 것이다.
    'kim' 이라는 객체의 레퍼런스 카운트가 2가 되는 셈.
    이것이 바로 얕은 복사

    이 때 'kim', 'se', 'hwan' 은 문자열 객체 (immutable) 하기 때문에 얕은 복사를 해도 문제가 X

    하지만 예를들어 li = [ [120, 30] ] 과 같이 리스트 내용이 mutable 한 객체일 경우 문제가 생긴다.
    [120,30] 이라는 객체는 mutabel 하기 때문에 얕은 복사를 했을 경우. [120, 30] 이라는 객체 내의 값을 변경시키면 
    참조하는 모든 변수들의 내용이 변경되기 떄문이다. 

    copy 모듈의 deepcopy 모듈을 사용해서 리스트 복사를 진행하면, immutable 객체는 얕은복사, mutable한 객체는 깊은 복사를 한다.

    -> 실제 python3.8 인터프리터로 직접 확인 해 본 결과

    original_list = [1,2,3,4] 로 정의하고
    test_list = original_list[:]
    test_list_2 = list(original_list)
    test_list_3 = original_list

    original_list[0] = 4 
    print(original_list)
    >>> [4,2,3,4]

    테스트 리스트 1번과 2번의 경우 [1,2,3,4] 로 출력
    테스트 리스트 3번은 [4,2,3,4] 로 출력 
    즉 테스트 리스트 1,2번 방식 또한 deepcopy라고 볼 수 있을 듯.

# 리스트

    베열은 여러 elements들이 연속된 메모리에 순차적으로 저장되는 매우 간단한 구조이다.
    연결 리스트(linked list)는 여러 분리된 노드가 서로 연결되어있는 구조이다. 자료구조의 내용을 순회 하는데에는
    모두 똑같이 효율적이지만, 어떤 요소에 직접 접근할 때 배열의 시간 복잡도는 O(1)이고, 연결 리스튼 O(n)이다.
    (연결리스트는 어떤 노드에 접근하려면 처음부터 순회를 시작해야 함)

    연결 리스트에 어떤 노드를 삽입할때 그 위치를 안다면 연결 리스트 노드의 수에 상관 없이 시간 복잡도는 O(1)
    배열에서 어떤 위치에 항목을 삽입하려면, 그 위치에서부터 모든 항목을 오른쪽으로 옮겨야 하므로 시간 복잡도는 O(n)
    
    그러니까 데이터 삽입보다(처음이나 끝에 삽입하는 건 문제 없나?) 직접 접근을 많이하는 데이터라면 배열로.
    데이터 접근보다, 중간 삽입이 많다면 연결 리스트로 구현?


    배열과 연결 리스트는 매우 큰 차이가 있다. (파이썬의 List는 배열과 동일하다)